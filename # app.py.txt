# app.py

import streamlit as st
import pandas as pd
import numpy as np
import joblib

# Load the data and model
# You will need to save your trained model to a file, e.g., using joblib
# For example: joblib.dump(model, 'crop_prediction_model.pkl')
# Then load it here:
# model = joblib.load('crop_prediction_model.pkl')

# Load the data from your CSV file to get the list of unique values for dropdowns
data = pd.read_csv("JHARKHAND_merged (1).xlsx - Sheet1.csv")

# Get unique values for dropdowns from the CSV file
districts = data['District'].unique()
blocks = data['Block'].unique()
seasons = data['Season'].unique()
soil_types = data['Soil Type'].unique()
soil_textures = data['Soil Texture'].unique()
categories = data['Category'].unique()

st.title("ğŸŒ± Crop Prediction Model Interface")
st.write("Enter the details below to find the most suitable crops for your location.")

# Create the input widgets
district_selected = st.selectbox("Select District:", districts)
block_selected = st.selectbox("Select Block:", blocks)
season_selected = st.selectbox("Select Season:", seasons)
temperature = st.slider("Select Temperature (Â°C):", min_value=10.0, max_value=45.0, value=25.0)
soil_type_selected = st.selectbox("Select Soil Type:", soil_types)
soil_texture_selected = st.selectbox("Select Soil Texture:", soil_textures)
category_selected = st.selectbox("Select Category:", categories)

# Prediction Button
if st.button("Get Suitable Crops"):
    # This is where you would place your model's prediction logic.
    # The current notebook uses a data-based lookup,
    # so we will use a function to find suitable crops from your data.

    # Filter the data based on user input
    filtered_data = data[
        (data['District'] == district_selected) &
        (data['Block'] == block_selected) &
        (data['Season'] == season_selected) &
        (data['Soil Type'] == soil_type_selected) &
        (data['Soil Texture'] == soil_texture_selected) &
        (data['Category'] == category_selected)
    ]

    # You might want to add a temperature range filter as well
    # For example: (filtered_data['Temperature'] >= (temperature - 5)) & (filtered_data['Temperature'] <= (temperature + 5))

    if not filtered_data.empty:
        # Sort by suitability and display the results
        top_crops = filtered_data.sort_values(by='Suitability', ascending=False)
        
        st.subheader("Results:")
        
        for index, row in top_crops.iterrows():
            st.success(f"**Crop:** {row['Crop']} - **Suitability:** {row['Suitability']}%")
    else:
        st.warning("No suitable crops found for the selected criteria.")